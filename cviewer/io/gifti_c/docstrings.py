docstrings = \
{'gifti_DA_rows_cols': " return the number of 'rows' and 'columns' of a DataArray element\n define rows to be the number of nodes, which should be the slowest\n changing element, depending on the index order (kuru kuru pa)\n",
 'gifti_add_empty_CS': ' add an empty CoordSystem struct to the DataArray\n',
 'gifti_add_empty_darray': ' add an empty DataArray struct to the gim->darray list\n this both reallocates gim->darray and allocates gim->darray[new]\n if num_to_add > 0: add that many elements\n if defaults      : init each element with default values\n return 0 on success\n        1 on error\n',
 'gifti_add_to_meta': " add the name=value pair to the MetaData lists\n if the name already exists, fail, unless 'replace' is set\n return 0 on success, 1 on error\n",
 'gifti_add_to_nvpairs': ' add the given name=value pair to the nvpairs struct\n this allocates memory for the p->name and p->value arrays, along\n with duplicating the passed name/value strings\n',
 'gifti_alloc_DA_data': ' allocate nvals*nbyper bytes of (zero-filled) data in each DataArray\n (in dalist or simply in gim)\n return 0 on success\n        1 on error\n',
 'gifti_check_swap': ' if endian does not match that of this CPU, swap the data bytes\n return whether bytes were swapped\n',
 'gifti_clear_CoordSystem': ' simply set the struct contents to empty\n',
 'gifti_clear_DataArray': ' clear the DataArray element\n',
 'gifti_clear_LabelTable': ' simply set the struct contents to empty\n',
 'gifti_clear_float_zeros': ' remove trailing zeros from string of printed float\n return  1 if something was cleared\n         0 if not\n',
 'gifti_clear_gifti_image': ' simply clear all contents of the passed gifti_image\n (being explicit with pointers)\n return 0 on success\n        1 on error\n',
 'gifti_clear_nvpairs': ' simply set the struct contents to empty\n',
 'gifti_compare_coordsys': ' check pointers, compare names and xforms\n only state diffs in the verb=3 case\n',
 'gifti_compare_gifti_data': ' find any differences between the two sets of image data\n verb  0-2+ = quiet, state diff, state per DA\n return 0 if they are the same, 1 if they differ\n',
 'gifti_compare_gifti_images': ' find any differences between the two images\n verb  0-3 = quiet, state diff, state per DA, state all diffs\n return 0 if they are the same, 1 if they differ\n',
 'gifti_compare_labeltable': ' check pointers, lengths and contents\n only state diffs in the verb=3 case\n',
 'gifti_compare_nvpairs': ' check pointers, compare lengths, then check the Names in each list,\n and see if there is a matching Name=Value pari\n only state diffs in the verb=3 case\n',
 'gifti_compare_raw_data': ' compare raw data, returing the first location difference\n(return -1 if the pointers differ in whether they are set) \n',
 'gifti_convert_to_float': ' convert all data to NIFTI_TYPE_FLOAT32\n for each DataArray\n     if data exists, convert it (free old, allocate new)\n     else, leave as NULL\n',
 'gifti_copy_CoordSystem': ' dupliate the giiCoordSystem struct (passing NULL is okay)\n',
 'gifti_copy_DA_meta': " copy any DataArray MetaData named 'name' from dest to src (replace old)\n return 0 on success, 1 on failure to find, -1 on error\n",
 'gifti_copy_DA_meta_many': " copy any DataArray MetaData named 'name' from dest to src (replace old)\n (apply to list of DAs, or to all)\n return 0 on success, 1 on failure to find, -1 on error\n",
 'gifti_copy_DataArray': ' duplicate the given giiDataArray struct, optionally including data\n Allocate for a new struct, and fill it so that the contents are\n identical (sans pointers) to orig.  Sub-structure arrays will need\n to be allocated, also.\n If get_data is not set, gnew->data will be left as NULL.\n \n return the address of the newly allocated structure\n',
 'gifti_copy_LabelTable': ' dupliate the contents of the giiLabelTable struct\n',
 'gifti_copy_all_DA_meta': ' copy ALL DataArray MetaData from dest to src (replace old)\n return 0 on success, 1 on failure to find, -1 on error\n',
 'gifti_copy_char_list': ' dupliate the list of strings\n',
 'gifti_copy_gifti_image': ' duplicate the given gifti_image struct, optionally including data\n Allocate and copy all contents of the gifti_image structure and\n sub-structures.  If copy_data is not set, all data pointers within\n DataArray elements will be left as NULL.\n \n return a pointer to the newly allocated structure\n',
 'gifti_copy_gifti_meta': " copy any GIFTI MetaData named 'name' from dest to src (replace old)\n return 0 on success, 1 on failure to find, -1 on error\n",
 'gifti_copy_nvpairs': ' dupliate the contents of one nvpairs structure into an empty one\n return 0 on success\n',
 'gifti_create_image': ' allocate and return a newly created gifti_image_struct\n if numDA > 0, allocate and initialize gim->darray\n if intent is a valid NIFTI_INTENT code, set it in all DataArray elements\n if dtype is a valid NIFTI_TYPE, set it in all DA elements\n if dims is set (MUST be of length 6), set the dims in all DA elements\n if alloc_data, allocate zero-filled data in each DA element\n note that if numDA <= 0, the function returns an empty gifti_image\n',
 'gifti_darray_nvals': ' compute the total number of data values in a DataArray element\n',
 'gifti_datatype2str': ' return the NIFTI_TYPE_ value string corresponding to the given type\n',
 'gifti_datatype_sizes': ' given a datatype, return the corresponding bytes per value and swapsize\n nbyper and swapsize are filled only if the pointers are set\n',
 'gifti_disp_CoordSystem': ' display the contents of the CoordSystem struct\n',
 'gifti_disp_DataArray': " display the contents of the DataArray struct\n if 'subs' is set, display the contents of the sub-structures\n",
 'gifti_disp_LabelTable': ' display the contents of the LabelTable struct\n',
 'gifti_disp_dtd_url': ' print the gifti DTD URL\n',
 'gifti_disp_gifti_image': " display the contents of the gifti_image struct\n if 'subs' is set, display the contents of the sub-structures, such\n as all of the DataArray elements\n",
 'gifti_disp_hex_data': ' display data in hexidecimal, on one line\n if mesg is set, print the message first\n if fp is not set, print to stdout\n',
 'gifti_disp_lib_hist': ' print the gifti library history string\n',
 'gifti_disp_lib_version': ' print the gifti library version string\n',
 'gifti_disp_nvpairs': ' display the contents of the nvpairs struct\n',
 'gifti_disp_raw_data': " print raw data (nvals of type 'type') to the given file stream\n possibly write a trailing newline\n",
 'gifti_find_DA': ' find giiDataArray element #index of the given intent\n',
 'gifti_find_DA_list': " return an allocated list of giiDataArray pointers of the given intent\n 'list' should be freed or taken\n",
 'gifti_free_CS_list': ' free the CoordSystem array from a DataArray\n passing NULL is okay\n',
 'gifti_free_CoordSystem': ' free the CoordSystem struct and all its contents\n the CoordSystem pointer is garbage after this call\n passing NULL is okay\n',
 'gifti_free_DataArray': ' free the DataArray struct and all its contents\n the DataArray pointer is garbage after this call\n passing NULL is okay\n',
 'gifti_free_DataArray_list': ' free the DataArray list (the array and all its contents)\n the darray list pointer is garbage after this call\n passing NULL is okay\n',
 'gifti_free_LabelTable': ' free the contents of the LabelTable struct (but not the pointer)\n passing NULL is okay\n',
 'gifti_free_image': ' free the gifti_image struct and all its contents\n passing NULL (to this and any child function) should be okay\n the pointer is garbage after this call\n',
 'gifti_free_image_contents': ' free the contents of the gifti_image struct (but not the pointer)\n the pointer is garbage after this call\n',
 'gifti_free_nvpairs': ' free the contents of the nvpairs struct (but not the pointer)\n passing NULL is okay\n',
 'gifti_get_meta_value': ' given metadata name, return the corresponding value (or NULL)\n no allocation is done here\n',
 'gifti_get_this_endian': ' return the current CPU endian: GIFTI_ENDIAN_BIG or _LITTLE\n',
 'gifti_gim_DA_size': ' compute the number of bytes summed over all DataArray elements\n if in_mb is set, return the (rounded) number of megabytes\n (i.e. 17 is 17 MB)\n',
 'gifti_image_has_data': ' return whether data exists\n - darray, each darray[i] and darray[i]->data must be set\n \n return 1 if true, 0 otherwise\n',
 'gifti_intent_from_string': ' Given a NIFTI_INTENT string, such as "NIFTI_INTENT_NODE_INDEX",\n return the corresponding integral intent code.  The intent code is\n the macro value defined in nifti1.h.\n return 0 on failure (NIFTI_INTENT_NONE)\n',
 'gifti_intent_is_valid': ' Return whether the given code is a valid NIFTI_INTENT code.\n',
 'gifti_intent_to_string': ' Given a NIFTI_TYPE value, such as NIFTI_TYPE_INT16, return the\n corresponding macro label as a string.  The dtype code is the\n macro value defined in nifti1.h.\n',
 'gifti_list_index2string': ' return the string at the given index of the given list\n This function is meant to index into one of the gifti_*_list arrays,\n while being certain that the index is not out of range.\n',
 'gifti_read_da_list': ' Similar to gifti_read_data, this function also takes an integer list of\n DataArray indices to populate the gifti_image structure with.\n The indices are be zero-based, can have repeats and can be in any order.\n A simple example to read 3 DA elements (with 2 repeats) might be:\n   gifti_image * gim;\n   int           ilist[5] = { 3, 0, 7, 7, 3 };\n   gim = gifti_read_da_list("my_data.gii", 1, ilist, 5);\n return an allocated gifti_image struct on success,\n        NULL on error\n',
 'gifti_read_dset_numDA': ' read a dataset, just for numDA\n may write faster gxml function for this, if it seems important\n',
 'gifti_read_extern_DA_data': ' Allocate and fill the data array with data read from the given\n external file.\n return 0 on success\n',
 'gifti_read_image': ' This is the main dataset reading routine.  Read a GIFTI dataset\n and return the corresponding gifti_image structure.\n Reading data is optional, via the read_data flag.\n User variables should already be set (via accessor functions).\n return an allocated gifti_image struct on success,\n        NULL on error\n',
 'gifti_set_DA_atrs': ' initialize an existing DataArray structure given a list of name=value\n attribute pairs\n if alen > 0, consider it the length of the attr list\n else         process until attr[i] == NULL\n if add_to_extras, add any bad attribute pairs to ex_atrs\n else              whine about any bad ones and return\n',
 'gifti_set_DA_defaults': ' fill DataArray element with default values\n return 0 on success\n        1 on error\n',
 'gifti_set_DA_meta': ' set MetaData name/value pairs in all DAs in list (or all in gim)\n',
 'gifti_set_atr_in_DAs': ' set all DataArray attributes of the given name to the given value\n',
 'gifti_set_dims_all_DA': ' set num_dims, dims and nvals in every DataArray element\n return 0 on success\n        1 on error\n',
 'gifti_set_extern_filelist': ' Apply the file list as external files.\n The files are assumed to be partitioned by DataArray entries.  So\n the list length must divide numDA evenly.\n External files are not checked for her, as this is independent of any\n read or write operation.\n return 0 on success\n',
 'gifti_str2attr_darray': ' set the DataArray attribute, based on the name=value string pair\n return 0 on success\n        1 on error\n',
 'gifti_str2attr_gifti': ' apply the attr=value GIFTI attribute to the gifti_image\n return 0 on success\n',
 'gifti_str2datatype': ' return the NIFTI_TYPE_ value corresponding to the given string\n',
 'gifti_str2encoding': ' return the index for a GIFTI_ENDODING_* string\n',
 'gifti_str2endian': ' return the GIFTI_ENDIAN_ value corresponding to the given string\n',
 'gifti_str2ind_ord': ' return the index for a GIFTI_IND_ORD_* string\n',
 'gifti_strdiff': ' like strcmp, but also return:\n     0: if both pointers are NULL\n     1: if exactly one is NULL\n',
 'gifti_strdup': ' duplicate the given string\n',
 'gifti_swap_2bytes': ' swap sets of 2-byte values\n',
 'gifti_swap_4bytes': ' swap sets of 4-byte values\n',
 'gifti_swap_Nbytes': ' swap sets of N-byte values\n \n if N < 2         : just return\n if N = 2 or N = 4: call explicit function for that size (speed)\n else             : swap in a loop\n',
 'gifti_update_nbyper': ' update nbyper/swapsize for all DataArray elements\n return 0 on success\n        1 on error\n',
 'gifti_valid_DataArray': ' determine whether the given DataArray struct seems valid\n if whine is set, print error messages for any failures\n return 1, if valid\n        0, if not\n',
 'gifti_valid_LabelTable': ' check whether pointers are valid and consistent with length\n no check is done on the actual indices or labels\n',
 'gifti_valid_datatype': ' check that the datatype is in the list\n',
 'gifti_valid_dims': ' check that dimension values are consistent (and with datatype)\n \n     - num_dim is in range\n     - each dims[c] is postive (c < num_dim)\n     - nvals is product of dims\n     - datatype is valie (required to check nbyper)\n     - nbyper is correct\n',
 'gifti_valid_gifti_image': ' check for validity of the gifti_image (including sub-structures)\n if whine is set, complain about any errors\n return 1 if valid, 0 otherwise\n',
 'gifti_valid_int_list': ' return whether the list values are from min to max\n',
 'gifti_valid_nbyper': ' check that nbyper is one of the values in gifti_type_list\n',
 'gifti_valid_num_dim': ' check the bounds on num_dim\n',
 'gifti_valid_nvpairs': ' check whether pointers are valid and consistent with length\n',
 'gifti_write_extern_DA_data': ' Write DA data to the given external file.\n Note: the given ext_offset _must_ refer to the current end of file.\n return 0 on success\n',
 'gifti_write_image': ' This is the main dataset writing routine.\n User variables should be set before this point.\n return 0 on success\n        1 on error\n',
 'gifticlib_version': ' return the gifti library version string\n'}